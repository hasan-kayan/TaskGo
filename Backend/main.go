package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	"github.com/hasan-kayan/TaskGo/database"
	"github.com/hasan-kayan/TaskGo/middleware"
	"github.com/hasan-kayan/TaskGo/routes"

	_ "github.com/hasan-kayan/TaskGo/docs" // Swagger docs (generated by swag)
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

/*
	╭──────────────────────────────────────────────────────────────╮
	│  TaskGo – main.go                                            │
	│  Starts the HTTP API, wiring middleware, routes, and shutdown│
	╰──────────────────────────────────────────────────────────────╯
*/

// @title       TaskGo API
// @version     1.0
// @description API for managing books and processing URLs
// @host        localhost:8080
// @BasePath    /
func main() {
	log.Println("🚀  Starting TaskGo API...")

	// ─────────────────────────────────────────────────────
	// 1.  Load ENV (fallback handled inline)
	// ─────────────────────────────────────────────────────
	appEnv := getEnv("APP_ENV", "dev")      // dev | prod
	httpPort := getEnv("HTTP_PORT", "8080") // e.g. 80 in prod
	addr := fmt.Sprintf(":%s", httpPort)

	// ─────────────────────────────────────────────────────
	// 2.  Database connection
	// ─────────────────────────────────────────────────────
	database.ConnectDB() // DSN, log mode, migrate flags are env-driven

	// ─────────────────────────────────────────────────────
	// 3.  Gin engine & middleware
	// ─────────────────────────────────────────────────────
	if appEnv == "prod" {
		gin.SetMode(gin.ReleaseMode)
	}

	r := gin.New()
	r.Use(gin.Recovery())           // panic-safe
	r.Use(middleware.Logger())      // JSON request logs
	r.Use(middleware.RateLimiter()) // per-IP throttling
	r.Use(cors.Default())           // 🔓 permissive – tighten in prod

	// Swagger only in non-prod
	if appEnv != "prod" {
		r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	}

	// Routes
	routes.SetupRoutes(r)

	// ─────────────────────────────────────────────────────
	// 4.  HTTP server (graceful shutdown)
	// ─────────────────────────────────────────────────────
	srv := &http.Server{
		Addr:         addr,
		Handler:      r,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	go func() {
		log.Printf("🚦  Listening on http://localhost:%s (env=%s)\n", httpPort, appEnv)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("❌  Server failed: %v\n", err)
		}
	}()

	// Wait for CTRL-C / SIGTERM
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("🛑  Shutting down…")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("❌  Graceful shutdown failed: %v\n", err)
	}

	log.Println("✅  Server exited cleanly")
}

// getEnv returns env value or fallback.
func getEnv(key, fallback string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return fallback
}
